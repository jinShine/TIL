# 1.External Store

### Separation of Concerns

> [관심사의 분리](https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC\_%EB%B6%84%EB%A6%AC)

관심사 분리(separation of concerns, SoC)는 컴퓨터 프로그램을 구별된 부분으로 분리시키는 디자인 원칙\
**관심사**란 프로그램 코드에 영향을 미치는 정보의 집합이며, 각 부문은 개개의 관심사를 해결



흔히 사용되는 Layered Architecture에선 사용자에게 가까운 것과 사용자에게서 먼 것으로 구분한다. 가장 가까운 건 UI를 다루는 부분, 그 다음엔 Business Logic을 다루는 부분, 그 너머에는 데이터에 접근하고 저장하는 부분으로 나눌 수 있게 된다. 각 부분은 하나의 역할, 하나의 관심사로 격리됨으로써 복잡도를 낮추게 된다.

#### **Layered Architecture**

> [Software Architecture Patterns - Layered Architecture](https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html)

**관심사를 분리하는 기준 - 설계**

Layered Architecture에서는 **사용자에게 가까운 것(UI), 사용자와 먼 것(비즈니스 로직)** 으로 구분

`🙋🏻‍♀️ 사람` → `🔘 스위치(UI)` → `⚙️ 모터(비즈니스 로직)` → `🏍 바퀴(DB)`

* 사람이 **스위치**를 조종하면(UI)
* **모터**가 움직여서(비즈니스 로직을 이용)
* **바퀴**를 굴릴 수 있음(DB에 접근하고 처리할 수 있음)



**관심사를 분리하는 기준 - 프로세스**

간단하게 `Input` → `Process` → `Output` 3단계로 코드를 적절히 구분만 해도 코드를 이해하고 유지보수하는데 크게 도움이 됨\
하나의 Output은 다시 사용자에게 Input을 요청하게 되고, 일반적인 프로그램은 다음과 같이 **계속 순환하는 구조**가 됨

1. Input: 프로그램 시작
2. Process: 프로그램 초기화
3. Output: 사용자에게 초기 UI 보여주기
4. Input: 사용자의 입력
5. Process: 사용자의 입력에 따라 처리
6. Output: 처리 결과 보여주기
7. Input: 사용자의 또 다른 입력
8. 반복

### 장점

각각은 하나의 역할(관심사)만 수행하기 때문에 복잡도가 낮아짐





### Flux Architecture

> [Flux](https://facebook.github.io/flux/docs/in-depth-overview/)
>
> [Flux (한국어)](https://haruair.github.io/flux/docs/overview.html)
>
> [Redux의 핵심](https://ko.redux.js.org/tutorials/essentials/part-1-overview-concepts)

Facebook(현 Meta)에서 MVC의 대안으로 내세운 아키텍처. 2-way binding을 썼을 때 생길 수 있는 Model-View의 복잡한 관계(전통적인 MVC에선 이런 상황을 지양한다)를 겨냥해 명확히 “**unidirectional data flow**”를 강조한다.

1. Action → 이벤트/메시지 같은 객체.
2. Dispatcher → (여러) Store로 Action을 전달. 메시지 브로커와 유사하다.
3. Store (여러 개) → 받은 Action에 따라 상태를 변경. 상태 변경을 알림.
4. View → Store의 상태를 반영.

Redux는 단일 Store를 사용함으로써 좀 더 단순한 그림을 제안한다.

1. Action
2. Store → dispatch를 통해 Action을 받고, 사용자가 정의한 reducer를 통해 State를 변경한다.
3. View → State를 반영.



### External Store

> [forceUpdate와 같은 것이 있습니까?](https://ko.reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate)

특별히 쓰이지 않는 상태라고 해도(React는 이걸 판단하기 어려움), “상태가 바뀌면” 해당 컴포넌트와 하위 컴포넌트를 다시 렌더링한다.

```tsx
const [, setState] = useState({});
const forceUpdate = () => setState({});
```

커스텀 Hook으로 만들자.

```tsx
function useForceUpdate() {
	const [, setState] = useState({});
	return useCallback(() => setState({}), []);
}
```

이런 접근을 잘 하면, React가 UI를 담당하고, 순수한 TypeScript(또는 JavaScript)가 비즈니스 로직을 담당하는, 관심사의 분리(Separation of Concerns)를 명확히 할 수 있다. 자주 바뀌는 UI 요소에 대한 테스트 대신, 오래 유지되는(바뀌면 치명적인) 비즈니스 로직에 대한 테스트 코드를 작성해 유지보수에 도움이 되는 테스트 코드를 치밀하게 작성할 수 있다.\


관심사의 분리

* 나는 너가 뭘 하는지 궁금하지 않아, 알빠야
* 각 레이어별로 레이어가 맡아야 하는 역할만 하면 된다.
